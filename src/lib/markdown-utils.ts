/**
 * Markdown Enhancement Utilities
 * 
 * Collection of functions to convert various markdown patterns into styled HTML components.
 * These functions post-process HTML generated by markdown parsers to create rich, interactive UI elements.
 */

/**
 * Converts standard HTML tables (from markdown) to styled tables with Tailwind classes
 */
export function convertMarkdownTablesToStyledHtml(html: string): string {
    const tableRegex = /<table>([\s\S]*?)<\/table>/g;

    return html.replace(tableRegex, (match, tableContent) => {
        const theadMatch = tableContent.match(/<thead>([\s\S]*?)<\/thead>/);
        const tbodyMatch = tableContent.match(/<tbody>([\s\S]*?)<\/tbody>/);

        if (!theadMatch || !tbodyMatch) return match;

        const headerCells = theadMatch[1].match(/<th>(.*?)<\/th>/g) || [];
        const headers = headerCells.map((cell: string) =>
            cell.replace(/<\/?th>/g, '').trim()
        );

        const bodyRows = tbodyMatch[1].match(/<tr>([\s\S]*?)<\/tr>/g) || [];
        const rows = bodyRows.map((row: string) => {
            const cells = row.match(/<td>(.*?)<\/td>/g) || [];
            return cells.map((cell: string) =>
                cell.replace(/<\/?td>/g, '').trim()
            );
        });

        let styledTable = '<div class="table-scroll-wrapper my-4">';
        styledTable += '<table class="w-full border border-zinc-200 dark:border-zinc-800 rounded-lg overflow-hidden md:min-w-[500px]">';

        styledTable += '<thead class="bg-zinc-100 dark:bg-zinc-900"><tr class="hover:bg-zinc-50 dark:hover:bg-zinc-900/50 transition-colors">';
        headers.forEach((header: string) => {
            styledTable += `<th class="px-3 py-2 sm:px-4 sm:py-3 text-left text-xs font-medium text-zinc-600 dark:text-zinc-400 uppercase tracking-wider">${header}</th>`;
        });
        styledTable += '</tr></thead>';

        styledTable += '<tbody class="divide-y divide-zinc-200 dark:divide-zinc-800 bg-white dark:bg-zinc-950">';
        rows.forEach((row: string[]) => {
            styledTable += '<tr class="hover:bg-zinc-50 dark:hover:bg-zinc-900/50 transition-colors">';
            row.forEach((cell: string) => {
                styledTable += `<td class="px-3 py-2 sm:px-4 sm:py-3 text-sm text-zinc-700 dark:text-zinc-300 break-words">${cell}</td>`;
            });
            styledTable += '</tr>';
        });
        styledTable += '</tbody>';

        styledTable += '</table></div>';

        return styledTable;
    });
}

/**
 * Converts ASCII box tables (with box-drawing characters) to HTML tables
 */
export function convertAsciiTablesToHtml(html: string): string {
    const codeBlockRegex = /<pre><code>([\s\S]*?)<\/code><\/pre>/g;

    return html.replace(codeBlockRegex, (match, codeContent) => {
        if (codeContent.includes('╭') && codeContent.includes('╰')) {
            const lines = codeContent.split('\n').filter((line: string) => line.trim());
            const dataRows = lines.filter((line: string) =>
                line.includes('│') && !line.match(/^[╭╰─]+$/)
            );

            if (dataRows.length > 0) {
                const tableRows = dataRows.map((row: string) => {
                    const cells = row.split('│')
                        .filter((cell: string) => cell.trim())
                        .map((cell: string) => cell.trim());
                    return cells;
                });

                let tableHtml = '<div class="ascii-table-wrapper"><table class="ascii-table"><tbody>';
                tableRows.forEach((cells: string[]) => {
                    tableHtml += '<tr>';
                    cells.forEach((cell: string, index: number) => {
                        if (index === 0) {
                            tableHtml += `<td class="label-cell">${cell}</td>`;
                        } else {
                            tableHtml += `<td class="value-cell">${cell}</td>`;
                        }
                    });
                    tableHtml += '</tr>';
                });
                tableHtml += '</tbody></table></div>';

                return tableHtml;
            }
        }

        return match;
    });
}

/**
 * Converts simple ranking lists (with progress bars) to styled cards
 */
export function convertRankingListsToHtml(html: string): string {
    const codeBlockRegex = /<pre><code>([\s\S]*?)<\/code><\/pre>/g;

    return html.replace(codeBlockRegex, (match, codeContent) => {
        if (codeContent.includes('▬') && codeContent.match(/#\d+\s+\w+/)) {
            const lines = codeContent.split('\n').filter((line: string) => line.trim());
            const rankingItems: Array<{ rank: string, name: string, progress: number, description: string }> = [];

            let i = 0;
            while (i < lines.length) {
                const line = lines[i].trim();
                const rankMatch = line.match(/^#(\d+)\s+(\w+)\s+(▬+░*)/);

                if (rankMatch) {
                    const rank = rankMatch[1];
                    const name = rankMatch[2];
                    const progressBar = rankMatch[3];

                    const filled = (progressBar.match(/▬/g) || []).length;
                    const total = progressBar.length;
                    const progress = Math.round((filled / total) * 100);

                    let description = '';
                    if (i + 1 < lines.length && !lines[i + 1].trim().match(/^#\d+/)) {
                        description = lines[i + 1].trim();
                        i++;
                    }

                    rankingItems.push({ rank, name, progress, description });
                }
                i++;
            }

            if (rankingItems.length > 0) {
                let rankingHtml = '<div class="ranking-list">';
                rankingItems.forEach((item) => {
                    rankingHtml += `
            <div class="ranking-card">
              <div class="ranking-header">
                <span class="ranking-number">#${item.rank}</span>
                <span class="ranking-name">${item.name}</span>
              </div>
              <div class="ranking-progress-bar">
                <div class="ranking-progress-fill" style="width: ${item.progress}%"></div>
              </div>
              ${item.description ? `<div class="ranking-description">${item.description}</div>` : ''}
            </div>
          `;
                });
                rankingHtml += '</div>';

                return rankingHtml;
            }
        }

        return match;
    });
}

/**
 * Converts extended artist rankings (with scores and details) to styled cards
 */
export function convertExtendedRankingsToHtml(html: string): string {
    const codeBlockRegex = /<pre><code>([\s\S]*?)<\/code><\/pre>/g;

    return html.replace(codeBlockRegex, (match, codeContent) => {
        const lines = codeContent.split('\n').map((line: string) => line.trim()).filter((line: string) => line);

        const hasExtendedRankings = lines.some((line: string) =>
            /^#\d+\s+[A-Za-z\s]+\s+\d{2,3}$/.test(line)
        );

        if (hasExtendedRankings) {
            const rankings: Array<{
                rank: number;
                name: string;
                score: number;
                details: string[];
            }> = [];

            let currentRanking: { rank: number; name: string; score: number; details: string[] } | null = null;

            lines.forEach((line: string) => {
                const headerMatch = line.match(/^#(\d+)\s+(.+?)\s+(\d{2,3})$/);

                if (headerMatch) {
                    if (currentRanking) {
                        rankings.push(currentRanking);
                    }
                    currentRanking = {
                        rank: parseInt(headerMatch[1]),
                        name: headerMatch[2].trim(),
                        score: parseInt(headerMatch[3]),
                        details: []
                    };
                } else if (currentRanking && line) {
                    currentRanking.details.push(line);
                }
            });

            if (currentRanking) {
                rankings.push(currentRanking);
            }

            if (rankings.length > 0) {
                let rankingHtml = '<div class="extended-rankings">';
                rankings.forEach((ranking) => {
                    rankingHtml += `
            <div class="extended-ranking-card">
              <div class="extended-ranking-header">
                <span class="extended-ranking-number">#${ranking.rank}</span>
                <span class="extended-ranking-score">${ranking.score}</span>
              </div>
              <div class="extended-ranking-name">${ranking.name}</div>
              <div class="extended-ranking-details">
                ${ranking.details.map(detail => `<div class="extended-ranking-detail">${detail}</div>`).join('')}
              </div>
            </div>
          `;
                });
                rankingHtml += '</div>';

                return rankingHtml;
            }
        }

        return match;
    });
}

/**
 * Converts allocation profile boxes (with box-drawing characters) to styled cards
 */
export function convertAllocationProfilesToHtml(html: string): string {
    const codeBlockRegex = /<pre><code>([\s\S]*?)<\/code><\/pre>/g;

    return html.replace(codeBlockRegex, (match, codeContent) => {
        if (codeContent.includes('╭') && (
            codeContent.includes('DÉCOUVERTE') ||
            codeContent.includes('CONFIRMÉ') ||
            codeContent.includes('EXPERT'))) {

            const boxes = codeContent.split('╭────────────────────────╮').filter((box: string) => box.trim());
            const profiles: Array<{ title: string, allocations: Array<{ category: string, percentage: number }>, focus: string[] }> = [];

            boxes.forEach((box: string) => {
                const lines = box.split('\n').map((line: string) => line.trim()).filter((line: string) => line);

                if (lines.length === 0) return;

                let title = '';
                const allocations: Array<{ category: string, percentage: number }> = [];
                const focus: string[] = [];
                let inFocusSection = false;

                lines.forEach((line: string) => {
                    const cleanLine = line.replace(/[│╰─]/g, '').trim();

                    if (!cleanLine) return;

                    if (cleanLine.match(/^(DÉCOUVERTE|CONFIRMÉ|EXPERT)/)) {
                        title = cleanLine;
                    } else if (cleanLine.match(/^▔+$/)) {
                        // Skip separator
                    } else if (cleanLine.match(/\d+%/)) {
                        const match = cleanLine.match(/^([A-Za-z-]+)\s+(\d+)%/);
                        if (match) {
                            const category = match[1];
                            const percentage = parseInt(match[2]);
                            allocations.push({ category, percentage });
                        }
                    } else if (cleanLine.match(/^▬+░*$/)) {
                        // Skip progress bar visualization
                    } else if (cleanLine.startsWith('Focus:')) {
                        inFocusSection = true;
                        const artist = cleanLine.replace('Focus:', '').trim();
                        if (artist) focus.push(artist);
                    } else if (inFocusSection && cleanLine) {
                        focus.push(cleanLine);
                    }
                });

                if (title) {
                    profiles.push({ title, allocations, focus });
                }
            });

            if (profiles.length > 0) {
                let profileHtml = '<div class="allocation-profiles">';
                profiles.forEach((profile) => {
                    profileHtml += `
            <div class="allocation-card">
              <div class="allocation-title">${profile.title}</div>
              <div class="allocation-divider"></div>
              <div class="allocation-items">
          `;

                    profile.allocations.forEach((allocation) => {
                        profileHtml += `
              <div class="allocation-item">
                <div class="allocation-label">
                  <span class="allocation-category">${allocation.category}</span>
                  <span class="allocation-percentage">${allocation.percentage}%</span>
                </div>
                <div class="allocation-progress-bar">
                  <div class="allocation-progress-fill" style="width: ${allocation.percentage}%"></div>
                </div>
              </div>
            `;
                    });

                    if (profile.focus.length > 0) {
                        profileHtml += `
              <div class="allocation-focus">
                <div class="allocation-focus-label">Focus:</div>
                <div class="allocation-focus-artists">
                  ${profile.focus.map(artist => `<span class="allocation-artist">${artist}</span>`).join('')}
                </div>
              </div>
            `;
                    }

                    profileHtml += `
              </div>
            </div>
          `;
                });
                profileHtml += '</div>';

                return profileHtml;
            }
        }

        return match;
    });
}
