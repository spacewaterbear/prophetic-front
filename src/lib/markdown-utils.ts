/**
 * Markdown Enhancement Utilities
 * 
 * Collection of functions to convert various markdown patterns into styled HTML components.
 * These functions post-process HTML generated by markdown parsers to create rich, interactive UI elements.
 */

/**
 * Converts standard HTML tables (from markdown) to styled tables with Tailwind classes
 */
export function convertMarkdownTablesToStyledHtml(html: string): string {
    const tableRegex = /<table>([\s\S]*?)<\/table>/g;

    return html.replace(tableRegex, (match, tableContent) => {
        const theadMatch = tableContent.match(/<thead>([\s\S]*?)<\/thead>/);
        const tbodyMatch = tableContent.match(/<tbody>([\s\S]*?)<\/tbody>/);

        if (!tbodyMatch) return match;

        let headers: string[] = [];
        if (theadMatch) {
            const headerCells = theadMatch[1].match(/<th[^>]*>(.*?)<\/th>/g) || [];
            headers = headerCells.map((cell: string) =>
                cell.replace(/<\/?th[^>]*>/g, '').trim()
            );
        }

        const bodyRows = tbodyMatch[1].match(/<tr>([\s\S]*?)<\/tr>/g) || [];
        const rows = bodyRows.map((row: string) => {
            const cells = row.match(/<td[^>]*>(.*?)<\/td>/g) || [];
            return cells.map((cell: string) =>
                cell.replace(/<\/?td[^>]*>/g, '').trim()
            );
        });

        let styledTable = '<div class="table-scroll-wrapper premium-table-container my-4">';
        styledTable += '<table class="w-full border border-prophetic-border-default rounded-lg overflow-hidden md:min-w-[500px] bg-prophetic-bg-card shadow-sm">';

        if (headers.length > 0) {
            styledTable += '<thead class="bg-prophetic-bg-elevated/50 backdrop-blur-sm"><tr class="hover:bg-prophetic-bg-card-hover transition-colors">';
            headers.forEach((header: string) => {
                styledTable += `<th class="px-3 py-2 sm:px-4 sm:py-3 text-left text-xs font-semibold text-prophetic-text-secondary uppercase tracking-wider">${header}</th>`;
            });
            styledTable += '</tr></thead>';
        }

        styledTable += '<tbody class="divide-y divide-prophetic-border-default">';
        rows.forEach((row: string[]) => {
            styledTable += '<tr class="hover:bg-prophetic-bg-card-hover/50 transition-colors">';
            row.forEach((cell: string) => {
                styledTable += `<td class="px-3 py-2 sm:px-4 sm:py-3 text-sm text-prophetic-text-primary break-words">${cell}</td>`;
            });
            styledTable += '</tr>';
        });
        styledTable += '</tbody>';

        styledTable += '</table></div>';

        return styledTable;
    });
}

/**
 * Converts ASCII box tables (with box-drawing characters) to HTML tables
 */
export function convertAsciiTablesToHtml(html: string): string {
    const codeBlockRegex = /<pre><code>([\s\S]*?)<\/code><\/pre>/g;

    return html.replace(codeBlockRegex, (match, codeContent) => {
        if (codeContent.includes('╭') && codeContent.includes('╰')) {
            const lines = codeContent.split('\n').filter((line: string) => line.trim());
            const dataRows = lines.filter((line: string) =>
                line.includes('│') && !line.match(/^[╭╰─]+$/)
            );

            if (dataRows.length > 0) {
                const tableRows = dataRows.map((row: string) => {
                    const cells = row.split('│')
                        .filter((cell: string) => cell.trim())
                        .map((cell: string) => cell.trim());
                    return cells;
                });

                let tableHtml = '<div class="ascii-table-wrapper"><table class="ascii-table"><tbody>';
                tableRows.forEach((cells: string[]) => {
                    tableHtml += '<tr>';
                    cells.forEach((cell: string, index: number) => {
                        if (index === 0) {
                            tableHtml += `<td class="label-cell">${cell}</td>`;
                        } else {
                            tableHtml += `<td class="value-cell">${cell}</td>`;
                        }
                    });
                    tableHtml += '</tr>';
                });
                tableHtml += '</tbody></table></div>';

                return tableHtml;
            }
        }

        return match;
    });
}

/**
 * Converts simple ranking lists (with progress bars) to styled cards
 */
export function convertRankingListsToHtml(html: string): string {
    const codeBlockRegex = /<pre><code>([\s\S]*?)<\/code><\/pre>/g;

    return html.replace(codeBlockRegex, (match, codeContent) => {
        if (codeContent.includes('▬') && codeContent.match(/#\d+\s+\w+/)) {
            const lines = codeContent.split('\n').filter((line: string) => line.trim());
            const rankingItems: Array<{ rank: string, name: string, progress: number, description: string, hasAnalysis?: boolean }> = [];

            let i = 0;
            while (i < lines.length) {
                const line = lines[i].trim();
                const rankMatch = line.match(/^#(\d+)\s+(.+?)\s+(▬+░*)/);

                if (rankMatch) {
                    const rank = rankMatch[1];
                    const rawName = rankMatch[2];
                    const progressBar = rankMatch[3];

                    const hasMarkers = rawName.includes('-+-');
                    const cleanName = rawName.replace(/-\+-/g, '').trim();

                    const filled = (progressBar.match(/▬/g) || []).length;
                    const total = progressBar.length;
                    const progress = Math.round((filled / total) * 100);

                    let description = '';
                    if (i + 1 < lines.length && !lines[i + 1].trim().match(/^#\d+/)) {
                        description = lines[i + 1].trim();
                        i++;
                    }

                    rankingItems.push({
                        rank,
                        name: cleanName,
                        progress,
                        description,
                        hasAnalysis: hasMarkers
                    });
                }
                i++;
            }

            if (rankingItems.length > 0) {
                let rankingHtml = '<div class="ranking-list">';
                rankingItems.forEach((item) => {
                    rankingHtml += `
            <div class="ranking-card group ${item.hasAnalysis ? 'cursor-pointer' : ''}" ${item.hasAnalysis ? `data-analysis data-analysis-query="${item.name}"` : ''}>
              <div class="ranking-header flex justify-between items-center">
                <div class="flex items-center gap-2">
                  <span class="ranking-number text-prophetic-brand-primary font-bold">#${item.rank}</span>
                  <span class="ranking-name font-serif font-medium text-prophetic-text-primary text-base">${item.name}</span>
                </div>
              </div>
              <div class="ranking-progress-bar h-1.5 rounded-full overflow-hidden my-3">
                <div class="ranking-progress-fill bg-prophetic-brand-primary h-full rounded-full transition-all duration-1000" style="width: ${item.progress}%"></div>
              </div>
              ${item.description ? `<div class="ranking-description text-prophetic-text-tertiary text-[11px] leading-relaxed">${item.description}</div>` : ''}
            </div>
          `;
                });
                rankingHtml += '</div>';

                return rankingHtml;
            }
        }

        return match;
    });
}

/**
 * Converts extended artist rankings (with scores and details) to styled cards
 */
export function convertExtendedRankingsToHtml(html: string): string {
    const codeBlockRegex = /<pre><code>([\s\S]*?)<\/code><\/pre>/g;

    return html.replace(codeBlockRegex, (match, codeContent) => {
        const lines = codeContent.split('\n').map((line: string) => line.trim()).filter((line: string) => line);

        const hasExtendedRankings = lines.some((line: string) =>
            /^#\d+\s+.+?\s+\d{2,3}$/.test(line)
        );

        if (hasExtendedRankings) {
            const rankings: Array<{
                rank: number;
                name: string;
                score: number;
                details: string[];
                hasAnalysis?: boolean;
            }> = [];

            let currentRanking: { rank: number; name: string; score: number; details: string[]; hasAnalysis?: boolean } | null = null;

            lines.forEach((line: string) => {
                const headerMatch = line.match(/^#(\d+)\s+(.+?)\s+(\d{2,3})$/);

                if (headerMatch) {
                    if (currentRanking) {
                        rankings.push(currentRanking);
                    }
                    const rawName = headerMatch[2].trim();
                    const hasMarkers = rawName.includes('-+-');
                    const cleanName = rawName.replace(/-\+-/g, '').trim();

                    currentRanking = {
                        rank: parseInt(headerMatch[1]),
                        name: cleanName,
                        score: parseInt(headerMatch[3]),
                        details: [],
                        hasAnalysis: hasMarkers
                    };
                } else if (currentRanking && line) {
                    currentRanking.details.push(line);
                }
            });

            if (currentRanking) {
                rankings.push(currentRanking);
            }

            if (rankings.length > 0) {
                let rankingHtml = '<div class="extended-rankings">';
                rankings.forEach((ranking) => {
                    rankingHtml += `
            <div class="extended-ranking-card group ${ranking.hasAnalysis ? 'cursor-pointer' : ''}" ${ranking.hasAnalysis ? `data-analysis data-analysis-query="${ranking.name}"` : ''}>
              <div class="extended-ranking-header flex justify-between items-center mb-3">
                <div class="flex items-center gap-2">
                  <span class="extended-ranking-number text-prophetic-brand-primary font-bold">#${ranking.rank}</span>
                  <span class="extended-ranking-name font-serif font-semibold text-prophetic-text-primary text-base">${ranking.name}</span>
                </div>
                <span class="extended-ranking-score bg-prophetic-brand-primary/10 text-prophetic-brand-primary px-2 py-0.5 rounded text-xs font-bold">${ranking.score}</span>
              </div>
              <div class="extended-ranking-details space-y-1.5 pt-2 border-t border-prophetic-border-default/30">
                ${ranking.details.map(detail => {
                        const parts = detail.split(/\s{2,}/);
                        if (parts.length >= 2) {
                            return `<div class="extended-ranking-detail flex justify-between text-[11px]"><span class="text-prophetic-text-tertiary">${parts[0]}</span><span class="text-prophetic-text-primary font-medium">${parts[1]}</span></div>`;
                        }
                        return `<div class="extended-ranking-detail text-[11px] text-prophetic-text-tertiary">${detail}</div>`;
                    }).join('')}
              </div>
            </div>
          `;
                });
                rankingHtml += '</div>';

                return rankingHtml;
            }
        }

        return match;
    });
}

/**
 * Converts allocation profile boxes (with box-drawing characters) to styled cards
 */
export function convertAllocationProfilesToHtml(html: string): string {
    const codeBlockRegex = /<pre><code>([\s\S]*?)<\/code><\/pre>/g;

    return html.replace(codeBlockRegex, (match, codeContent) => {
        if (codeContent.includes('╭') && (
            codeContent.includes('DÉCOUVERTE') ||
            codeContent.includes('CONFIRMÉ') ||
            codeContent.includes('EXPERT'))) {

            const boxes = codeContent.split('╭────────────────────────╮').filter((box: string) => box.trim());
            const profiles: Array<{ title: string, allocations: Array<{ category: string, percentage: number }>, focus: string[] }> = [];

            boxes.forEach((box: string) => {
                const lines = box.split('\n').map((line: string) => line.trim()).filter((line: string) => line);

                if (lines.length === 0) return;

                let title = '';
                const allocations: Array<{ category: string, percentage: number }> = [];
                const focus: string[] = [];
                let inFocusSection = false;

                lines.forEach((line: string) => {
                    const cleanLine = line.replace(/[│╰─]/g, '').trim();

                    if (!cleanLine) return;

                    if (cleanLine.match(/^(DÉCOUVERTE|CONFIRMÉ|EXPERT)/)) {
                        title = cleanLine;
                    } else if (cleanLine.match(/^▔+$/)) {
                        // Skip separator
                    } else if (cleanLine.match(/\d+%/)) {
                        const match = cleanLine.match(/^([A-Za-z-]+)\s+(\d+)%/);
                        if (match) {
                            const category = match[1];
                            const percentage = parseInt(match[2]);
                            allocations.push({ category, percentage });
                        }
                    } else if (cleanLine.match(/^▬+░*$/)) {
                        // Skip progress bar visualization
                    } else if (cleanLine.startsWith('Focus:')) {
                        inFocusSection = true;
                        const artist = cleanLine.replace('Focus:', '').trim();
                        if (artist) focus.push(artist);
                    } else if (inFocusSection && cleanLine) {
                        focus.push(cleanLine);
                    }
                });

                if (title) {
                    profiles.push({ title, allocations, focus });
                }
            });

            if (profiles.length > 0) {
                let profileHtml = '<div class="allocation-profiles">';
                profiles.forEach((profile) => {
                    profileHtml += `
            <div class="allocation-card">
              <div class="allocation-title">${profile.title}</div>
              <div class="allocation-divider"></div>
              <div class="allocation-items">
          `;

                    profile.allocations.forEach((allocation) => {
                        profileHtml += `
              <div class="allocation-item">
                <div class="allocation-label">
                  <span class="allocation-category">${allocation.category}</span>
                  <span class="allocation-percentage">${allocation.percentage}%</span>
                </div>
                <div class="allocation-progress-bar">
                  <div class="allocation-progress-fill" style="width: ${allocation.percentage}%"></div>
                </div>
              </div>
            `;
                    });

                    if (profile.focus.length > 0) {
                        profileHtml += `
              <div class="allocation-focus">
                <div class="allocation-focus-label">Focus:</div>
                <div class="allocation-focus-artists">
                  ${profile.focus.map(artist => `<span class="allocation-artist">${artist}</span>`).join('')}
                </div>
              </div>
            `;
                    }

                    profileHtml += `
              </div>
            </div>
          `;
                });
                profileHtml += '</div>';

                return profileHtml;
            }
        }

        return match;
    });
}
