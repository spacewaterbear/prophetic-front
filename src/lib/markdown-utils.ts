/**
 * Markdown Enhancement Utilities
 * 
 * Collection of functions to convert various markdown patterns into styled HTML components.
 * These functions post-process HTML generated by markdown parsers to create rich, interactive UI elements.
 */

/**
 * Converts standard HTML tables (from markdown) to styled tables with Tailwind classes
 */
export function convertMarkdownTablesToStyledHtml(html: string): string {
    const tableRegex = /<table>([\s\S]*?)<\/table>/g;

    return html.replace(tableRegex, (match, tableContent) => {
        const theadMatch = tableContent.match(/<thead>([\s\S]*?)<\/thead>/);
        const tbodyMatch = tableContent.match(/<tbody>([\s\S]*?)<\/tbody>/);

        if (!tbodyMatch) return match;

        let headers: string[] = [];
        if (theadMatch) {
            const headerCells = theadMatch[1].match(/<th[^>]*>(.*?)<\/th>/g) || [];
            headers = headerCells.map((cell: string) =>
                cell.replace(/<\/?th[^>]*>/g, '').trim()
            );
        }

        const bodyRows = tbodyMatch[1].match(/<tr>([\s\S]*?)<\/tr>/g) || [];
        const rows = bodyRows.map((row: string) => {
            const cells = row.match(/<td[^>]*>(.*?)<\/td>/g) || [];
            return cells.map((cell: string) =>
                cell.replace(/<\/?td[^>]*>/g, '').trim()
            );
        });

        let styledTable = '<div class="table-scroll-wrapper premium-table-container my-4">';
        styledTable += '<table class="w-full border border-prophetic-border-default rounded-lg overflow-hidden md:min-w-[500px] bg-prophetic-bg-card shadow-sm">';

        if (headers.length > 0) {
            styledTable += '<thead class="bg-prophetic-bg-elevated/50 backdrop-blur-sm"><tr class="hover:bg-prophetic-bg-card-hover transition-colors">';
            headers.forEach((header: string) => {
                styledTable += `<th class="px-3 py-2 sm:px-4 sm:py-3 text-left text-xs font-semibold text-prophetic-text-secondary uppercase tracking-wider">${header}</th>`;
            });
            styledTable += '</tr></thead>';
        }

        styledTable += '<tbody class="divide-y divide-prophetic-border-default">';
        rows.forEach((row: string[]) => {
            styledTable += '<tr class="hover:bg-prophetic-bg-card-hover/50 transition-colors">';
            row.forEach((cell: string) => {
                styledTable += `<td class="px-3 py-2 sm:px-4 sm:py-3 text-sm text-prophetic-text-primary break-words">${cell}</td>`;
            });
            styledTable += '</tr>';
        });
        styledTable += '</tbody>';

        styledTable += '</table></div>';

        return styledTable;
    });
}

/**
 * Converts ASCII box tables (with box-drawing characters) to HTML tables
 */
export function convertAsciiTablesToHtml(html: string): string {
    const codeBlockRegex = /<pre><code>([\s\S]*?)<\/code><\/pre>/g;

    return html.replace(codeBlockRegex, (match, codeContent) => {
        if (codeContent.includes('╭') && codeContent.includes('╰')) {
            const lines = codeContent.split('\n').filter((line: string) => line.trim());
            const dataRows = lines.filter((line: string) =>
                line.includes('│') && !line.match(/^[╭╰─]+$/)
            );

            if (dataRows.length > 0) {
                const tableRows = dataRows.map((row: string) => {
                    const cells = row.split('│')
                        .filter((cell: string) => cell.trim())
                        .map((cell: string) => cell.trim());
                    return cells;
                });

                let tableHtml = '<div class="ascii-table-wrapper"><table class="ascii-table"><tbody>';
                tableRows.forEach((cells: string[]) => {
                    tableHtml += '<tr>';
                    cells.forEach((cell: string, index: number) => {
                        if (index === 0) {
                            tableHtml += `<td class="label-cell">${cell}</td>`;
                        } else {
                            tableHtml += `<td class="value-cell">${cell}</td>`;
                        }
                    });
                    tableHtml += '</tr>';
                });
                tableHtml += '</tbody></table></div>';

                return tableHtml;
            }
        }

        return match;
    });
}

/**
 * Converts simple ranking lists (with progress bars) to styled cards
 */
export function convertRankingListsToHtml(html: string): string {
    const codeBlockRegex = /<pre><code>([\s\S]*?)<\/code><\/pre>/g;

    return html.replace(codeBlockRegex, (match, codeContent) => {
        if (codeContent.includes('▬') && codeContent.match(/#\d+\s+\w+/)) {
            const lines = codeContent.split('\n').filter((line: string) => line.trim());
            const rankingItems: Array<{ rank: string, name: string, progress: number, description: string, hasAnalysis?: boolean }> = [];

            let i = 0;
            while (i < lines.length) {
                const line = lines[i].trim();
                const rankMatch = line.match(/^#(\d+)\s+(.+?)\s+(▬+░*)/);

                if (rankMatch) {
                    const rank = rankMatch[1];
                    const rawName = rankMatch[2];
                    const progressBar = rankMatch[3];

                    const hasMarkers = rawName.includes('-+-');
                    const cleanName = rawName.replace(/-\+-/g, '').trim();

                    const filled = (progressBar.match(/▬/g) || []).length;
                    const total = progressBar.length;
                    const progress = Math.round((filled / total) * 100);

                    let description = '';
                    if (i + 1 < lines.length && !lines[i + 1].trim().match(/^#\d+/)) {
                        description = lines[i + 1].trim();
                        i++;
                    }

                    rankingItems.push({
                        rank,
                        name: cleanName,
                        progress,
                        description,
                        hasAnalysis: hasMarkers
                    });
                }
                i++;
            }

            if (rankingItems.length > 0) {
                let rankingHtml = '<div class="ranking-list">';
                rankingItems.forEach((item) => {
                    rankingHtml += `
            <div class="ranking-card group ${item.hasAnalysis ? 'cursor-pointer' : ''}" ${item.hasAnalysis ? `data-analysis data-analysis-query="${item.name}"` : ''}>
              <div class="ranking-header flex justify-between items-center">
                <div class="flex items-center gap-2">
                  <span class="ranking-number text-prophetic-brand-primary font-bold">#${item.rank}</span>
                  <span class="ranking-name font-serif font-medium text-prophetic-text-primary text-base">${item.name}</span>
                </div>
              </div>
              <div class="ranking-progress-bar h-1.5 rounded-full overflow-hidden my-3">
                <div class="ranking-progress-fill bg-prophetic-brand-primary h-full rounded-full transition-all duration-1000" style="width: ${item.progress}%"></div>
              </div>
              ${item.description ? `<div class="ranking-description text-prophetic-text-tertiary text-[11px] leading-relaxed">${item.description}</div>` : ''}
            </div>
          `;
                });
                rankingHtml += '</div>';

                return rankingHtml;
            }
        }

        return match;
    });
}

/**
 * Converts extended artist rankings (with scores and details) to styled cards
 */
export function convertExtendedRankingsToHtml(html: string): string {
    const codeBlockRegex = /<pre><code>([\s\S]*?)<\/code><\/pre>/g;

    return html.replace(codeBlockRegex, (match, codeContent) => {
        const lines = codeContent.split('\n').map((line: string) => line.trim()).filter((line: string) => line);

        const hasExtendedRankings = lines.some((line: string) =>
            /^#\d+\s+.+?\s+\d{2,3}$/.test(line)
        );

        if (hasExtendedRankings) {
            const rankings: Array<{
                rank: number;
                name: string;
                score: number;
                details: string[];
                hasAnalysis?: boolean;
            }> = [];

            let currentRanking: { rank: number; name: string; score: number; details: string[]; hasAnalysis?: boolean } | null = null;

            lines.forEach((line: string) => {
                const headerMatch = line.match(/^#(\d+)\s+(.+?)\s+(\d{2,3})$/);

                if (headerMatch) {
                    if (currentRanking) {
                        rankings.push(currentRanking);
                    }
                    const rawName = headerMatch[2].trim();
                    const hasMarkers = rawName.includes('-+-');
                    const cleanName = rawName.replace(/-\+-/g, '').trim();

                    currentRanking = {
                        rank: parseInt(headerMatch[1]),
                        name: cleanName,
                        score: parseInt(headerMatch[3]),
                        details: [],
                        hasAnalysis: hasMarkers
                    };
                } else if (currentRanking && line) {
                    currentRanking.details.push(line);
                }
            });

            if (currentRanking) {
                rankings.push(currentRanking);
            }

            if (rankings.length > 0) {
                let rankingHtml = '<div class="extended-rankings">';
                rankings.forEach((ranking) => {
                    rankingHtml += `
            <div class="extended-ranking-card group ${ranking.hasAnalysis ? 'cursor-pointer' : ''}" ${ranking.hasAnalysis ? `data-analysis data-analysis-query="${ranking.name}"` : ''}>
              <div class="extended-ranking-header flex justify-between items-center mb-3">
                <div class="flex items-center gap-2">
                  <span class="extended-ranking-number text-prophetic-brand-primary font-bold">#${ranking.rank}</span>
                  <span class="extended-ranking-name font-serif font-semibold text-prophetic-text-primary text-base">${ranking.name}</span>
                </div>
                <span class="extended-ranking-score bg-prophetic-brand-primary/10 text-prophetic-brand-primary px-2 py-0.5 rounded text-xs font-bold">${ranking.score}</span>
              </div>
              <div class="extended-ranking-details space-y-1.5 pt-2 border-t border-prophetic-border-default/30">
                ${ranking.details.map(detail => {
                        const parts = detail.split(/\s{2,}/);
                        if (parts.length >= 2) {
                            return `<div class="extended-ranking-detail flex justify-between text-[11px]"><span class="text-prophetic-text-tertiary">${parts[0]}</span><span class="text-prophetic-text-primary font-medium">${parts[1]}</span></div>`;
                        }
                        return `<div class="extended-ranking-detail text-[11px] text-prophetic-text-tertiary">${detail}</div>`;
                    }).join('')}
              </div>
            </div>
          `;
                });
                rankingHtml += '</div>';

                return rankingHtml;
            }
        }

        return match;
    });
}

/**
 * Converts ASCII bar charts (Label  ||||||  score) to styled horizontal bar components
 */
export function convertBarChartsToHtml(html: string): string {
    const codeBlockRegex = /<pre><code>([\s\S]*?)<\/code><\/pre>/g;

    return html.replace(codeBlockRegex, (match, codeContent) => {
        const lines = codeContent.split('\n').map((l: string) => l.trim()).filter((l: string) => l);

        // Detect bar chart pattern: Label  |||||  number
        const barPattern = /^(.+?)\s{2,}(\|+)\s+(\d{1,3})$/;
        const barLines = lines.filter((line: string) => barPattern.test(line));

        // Only convert if ALL lines match the pattern (avoid false positives)
        if (barLines.length < 3 || barLines.length !== lines.length) return match;

        const bars: Array<{ label: string; score: number }> = barLines.map((line: string) => {
            const m = line.match(barPattern)!;
            return { label: m[1].trim(), score: parseInt(m[3]) };
        });

        const maxScore = Math.max(...bars.map((b: { score: number }) => b.score));

        let barHtml = '<div class="bar-chart-container">';
        bars.forEach((bar: { label: string; score: number }) => {
            const pct = Math.round((bar.score / 100) * 100);
            const isHigh = bar.score >= 75;
            const isMid = bar.score >= 50 && bar.score < 75;
            const tier = isHigh ? 'high' : isMid ? 'mid' : 'low';

            barHtml += `
        <div class="bar-chart-row">
          <span class="bar-chart-label">${bar.label}</span>
          <div class="bar-chart-track">
            <div class="bar-chart-fill bar-chart-fill--${tier}" style="width: ${pct}%"></div>
          </div>
          <span class="bar-chart-score bar-chart-score--${tier}">${bar.score}</span>
        </div>`;
        });
        barHtml += '</div>';

        return barHtml;
    });
}

/**
 * Converts performance comparison bars (+18%  ||||||||  Label) to styled components
 */
export function convertPerfBarsToHtml(html: string): string {
    const codeBlockRegex = /<pre><code>([\s\S]*?)<\/code><\/pre>/g;

    return html.replace(codeBlockRegex, (match, codeContent) => {
        const lines = codeContent.split('\n').map((l: string) => l.trim()).filter((l: string) => l);

        // Detect perf bar pattern: +18%  ||||||||  Label text
        const perfPattern = /^([+-]?\d+%?)\s{2,}(\|+)\s{2,}(.+)$/;
        const perfLines = lines.filter((line: string) => perfPattern.test(line));

        if (perfLines.length < 2 || perfLines.length !== lines.length) return match;

        const bars: Array<{ pct: string; pctNum: number; label: string; barLen: number }> = perfLines.map((line: string) => {
            const m = line.match(perfPattern)!;
            const pctStr = m[1].trim();
            const pctNum = parseFloat(pctStr.replace('%', ''));
            return { pct: pctStr.includes('%') ? pctStr : pctStr + '%', pctNum, label: m[3].trim(), barLen: m[2].length };
        });

        const maxBarLen = Math.max(...bars.map((b: { barLen: number }) => b.barLen));

        let perfHtml = '<div class="perf-bars-container">';
        bars.forEach((bar: { pct: string; pctNum: number; label: string; barLen: number }) => {
            const fillPct = Math.round((bar.barLen / maxBarLen) * 100);
            const isPositive = bar.pctNum > 0;
            const isNegative = bar.pctNum < 0;
            const sign = isPositive ? 'positive' : isNegative ? 'negative' : 'neutral';

            perfHtml += `
        <div class="perf-bar-row">
          <span class="perf-bar-pct perf-bar-pct--${sign}">${bar.pct}</span>
          <div class="perf-bar-track">
            <div class="perf-bar-fill perf-bar-fill--${sign}" style="width: ${fillPct}%"></div>
          </div>
          <span class="perf-bar-label">${bar.label}</span>
        </div>`;
        });
        perfHtml += '</div>';

        return perfHtml;
    });
}

/**
 * Converts comparison benchmark bars (+40% (est.) ======== Label) to styled components.
 * Distinguishes between estimated values (gradient fade), confirmed values (solid), and volatile items (amber shimmer).
 */
export function convertComparisonBarsToHtml(html: string): string {
    const codeBlockRegex = /<pre><code>([\s\S]*?)<\/code><\/pre>/g;

    return html.replace(codeBlockRegex, (match, codeContent: string) => {
        const decoded = codeContent
            .replace(/&amp;/g, '&')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>');

        const lines = decoded.split('\n').map((l: string) => l.trim()).filter((l: string) => l);

        // Detect pattern: +40% (est.) ======== Label text
        const compPattern = /^([+\-/\d.]+%)\s*(\(est\.\))?\s*(={3,})\s+(.+)$/;
        const compLines = lines.filter((line: string) => compPattern.test(line));

        // All lines must match, minimum 2 lines
        if (compLines.length < 2 || compLines.length !== lines.length) return match;

        const bars = compLines.map((line: string, index: number) => {
            const m = line.match(compPattern)!;
            const pctStr = m[1].trim();
            const isEstimated = !!m[2];
            const barLen = m[3].length;
            const label = m[4].trim();
            const isVolatile = pctStr.includes('/') || /\bvol\.?\b/i.test(label);
            return { pct: pctStr, isEstimated, barLen, label, isVolatile, index };
        });

        const maxBarLen = Math.max(...bars.map((b: { barLen: number }) => b.barLen));

        let output = '<div class="comp-bars-container">';
        bars.forEach((bar) => {
            const fillPct = Math.round((bar.barLen / maxBarLen) * 100);

            let fillMod = '';
            if (bar.isVolatile) fillMod = 'comp-bar-fill--volatile';
            else if (bar.isEstimated) fillMod = 'comp-bar-fill--estimated';
            else fillMod = 'comp-bar-fill--confirmed';

            const pctMod = bar.isVolatile ? 'comp-bar-pct--volatile' : 'comp-bar-pct--positive';

            // Display ± for +/- notation
            const displayPct = bar.pct.replace('+/-', '&plusmn;');

            // Small badge for estimated or volatile
            let badge = '';
            if (bar.isEstimated) {
                badge = '<span class="comp-bar-badge">est.</span>';
            } else if (bar.isVolatile) {
                badge = '<span class="comp-bar-badge comp-bar-badge--volatile">vol.</span>';
            }

            output += `
        <div class="comp-bar-row" style="--row-index: ${bar.index}">
          <div class="comp-bar-meta">
            <span class="comp-bar-pct ${pctMod}">${displayPct}</span>
            ${badge}
          </div>
          <div class="comp-bar-track">
            <div class="comp-bar-fill ${fillMod}" style="width: ${fillPct}%"></div>
          </div>
          <span class="comp-bar-label">${bar.label}</span>
        </div>`;
        });
        output += '</div>';

        return output;
    });
}

/**
 * Converts ASCII scatter plots (risk-return charts with * and o markers) to styled scatter plots.
 * Detects code blocks containing a L___ axis line, : separators, and * or o data point markers.
 */
export function convertScatterPlotsToHtml(html: string): string {
    const codeBlockRegex = /<pre><code>([\s\S]*?)<\/code><\/pre>/g;

    return html.replace(codeBlockRegex, (match, codeContent: string) => {
        const decoded = codeContent
            .replace(/&amp;/g, '&')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>');

        const lines = decoded.split('\n');

        // Detection: must have L___ axis line
        const axisLineIdx = lines.findIndex((l: string) => /^\s*L_+\s*$/.test(l));
        if (axisLineIdx === -1) return match;

        // Must have : separator lines with * or o markers
        let hasColon = false;
        let hasMarker = false;
        for (let i = 0; i < axisLineIdx; i++) {
            if (lines[i].includes(':')) {
                hasColon = true;
                const afterColon = lines[i].substring(lines[i].indexOf(':') + 1);
                if (/[*o]/.test(afterColon)) hasMarker = true;
            }
        }
        if (!hasColon || !hasMarker) return match;

        // Parse y-axis labels: lines matching  \d+%  :
        const yLabels: Array<{ value: number; lineIdx: number }> = [];
        for (let i = 0; i < axisLineIdx; i++) {
            const m = lines[i].match(/^\s*(\d+)%?\s*:/);
            if (m) {
                yLabels.push({ value: parseFloat(m[1]), lineIdx: i });
            }
        }
        if (yLabels.length < 2) return match;
        yLabels.sort((a: { lineIdx: number }, b: { lineIdx: number }) => a.lineIdx - b.lineIdx);

        // Parse x-axis labels from line after L___
        const xLabelLine = lines[axisLineIdx + 1] || '';
        const xLabels: Array<{ value: number; charPos: number }> = [];
        const xLabelRegex = /(\d+)%/g;
        let xm: RegExpExecArray | null;
        while ((xm = xLabelRegex.exec(xLabelLine)) !== null) {
            xLabels.push({ value: parseFloat(xm[1]), charPos: xm.index });
        }
        if (xLabels.length < 2) return match;

        // Parse x-axis title (line after x-axis labels)
        const xAxisTitle = (lines[axisLineIdx + 2] || '').trim();

        // Determine axis ranges
        const xMin = Math.min(...xLabels.map((l: { value: number }) => l.value));
        const xMax = Math.max(...xLabels.map((l: { value: number }) => l.value));
        const yDataMax = Math.max(...yLabels.map((l: { value: number }) => l.value));
        const yMin = 0;
        const yMax = Math.ceil((yDataMax + 1) / 5) * 5;

        // Parse data points by finding * or o markers on lines with :
        const points: Array<{
            label: string;
            xVal: number;
            yVal: number;
            isHighlighted: boolean;
        }> = [];

        for (let i = 0; i < axisLineIdx; i++) {
            const line = lines[i];
            const colonIdx = line.indexOf(':');
            if (colonIdx === -1) continue;

            const afterColon = line.substring(colonIdx + 1);

            for (let c = 0; c < afterColon.length; c++) {
                const ch = afterColon[c];
                if (ch !== '*' && ch !== 'o') continue;

                const markerCharPos = colonIdx + 1 + c;
                const label = afterColon.substring(c + 1).trim();

                // Calculate y-value by interpolation between y-axis labels
                let yVal = yLabels[0].value;
                const exactLabel = yLabels.find((yl: { lineIdx: number }) => yl.lineIdx === i);
                if (exactLabel) {
                    yVal = exactLabel.value;
                } else {
                    let prev = yLabels[0];
                    let next = yLabels[yLabels.length - 1];
                    for (let j = 0; j < yLabels.length; j++) {
                        if (yLabels[j].lineIdx <= i) prev = yLabels[j];
                        if (yLabels[j].lineIdx > i) { next = yLabels[j]; break; }
                    }
                    if (prev.lineIdx !== next.lineIdx) {
                        const t = (i - prev.lineIdx) / (next.lineIdx - prev.lineIdx);
                        yVal = prev.value + t * (next.value - prev.value);
                    }
                }

                // Calculate x-value by interpolation from marker character position vs x-axis label positions
                let xVal = xMin;
                let leftLabel = xLabels[0];
                let rightLabel = xLabels[xLabels.length - 1];
                for (let j = 0; j < xLabels.length - 1; j++) {
                    if (xLabels[j].charPos <= markerCharPos && xLabels[j + 1].charPos >= markerCharPos) {
                        leftLabel = xLabels[j];
                        rightLabel = xLabels[j + 1];
                        break;
                    }
                }
                if (markerCharPos <= leftLabel.charPos) {
                    xVal = leftLabel.value;
                } else if (markerCharPos >= rightLabel.charPos) {
                    xVal = rightLabel.value;
                } else {
                    const t = (markerCharPos - leftLabel.charPos) / (rightLabel.charPos - leftLabel.charPos);
                    xVal = leftLabel.value + t * (rightLabel.value - leftLabel.value);
                }

                points.push({ label, xVal, yVal, isHighlighted: ch === '*' });
                break; // one marker per line
            }
        }

        if (points.length < 2) return match;

        // Generate HTML
        const xRange = xMax - xMin;
        const yRange = yMax - yMin;

        // Y-axis labels + horizontal grid lines
        let yLabelHtml = '';
        let gridHtml = '';
        yLabels.forEach((yl: { value: number; lineIdx: number }) => {
            const pct = ((yl.value - yMin) / yRange) * 100;
            yLabelHtml += `<span class="scatter-plot-y-label" style="bottom: ${pct.toFixed(1)}%">${yl.value}%</span>`;
            gridHtml += `<div class="scatter-plot-gridline-h" style="bottom: ${pct.toFixed(1)}%"></div>`;
        });

        // Vertical grid lines (skip endpoints at 0% and 100%)
        xLabels.forEach((xl: { value: number; charPos: number }) => {
            const pct = ((xl.value - xMin) / xRange) * 100;
            if (pct > 0 && pct < 100) {
                gridHtml += `<div class="scatter-plot-gridline-v" style="left: ${pct.toFixed(1)}%"></div>`;
            }
        });

        // Data points
        let pointsHtml = '';
        points.forEach((pt: { label: string; xVal: number; yVal: number; isHighlighted: boolean }) => {
            const xPct = ((pt.xVal - xMin) / xRange) * 100;
            const yPct = ((pt.yVal - yMin) / yRange) * 100;
            const hlClass = pt.isHighlighted ? ' scatter-plot-point--highlighted' : '';

            pointsHtml += `
            <div class="scatter-plot-point${hlClass}" style="left: ${xPct.toFixed(1)}%; bottom: ${yPct.toFixed(1)}%">
              <div class="scatter-plot-dot"></div>
              <span class="scatter-plot-point-label">${pt.label}</span>
            </div>`;
        });

        // X-axis labels
        let xLabelHtml = '';
        xLabels.forEach((xl: { value: number; charPos: number }) => {
            const pct = ((xl.value - xMin) / xRange) * 100;
            xLabelHtml += `<span class="scatter-plot-x-label" style="left: ${pct.toFixed(1)}%">${xl.value}%</span>`;
        });

        return `
        <div class="scatter-plot-container">
          <div class="scatter-plot-wrapper">
            <div class="scatter-plot-y-axis-labels">
              ${yLabelHtml}
            </div>
            <div class="scatter-plot-area">
              ${gridHtml}
              ${pointsHtml}
            </div>
          </div>
          <div class="scatter-plot-x-axis-labels">
            ${xLabelHtml}
          </div>
          ${xAxisTitle ? `<div class="scatter-plot-x-title">${xAxisTitle}</div>` : ''}
        </div>`;
    });
}

/**
 * Converts allocation profile boxes (with box-drawing characters) to styled cards
 */
export function convertAllocationProfilesToHtml(html: string): string {
    const codeBlockRegex = /<pre><code>([\s\S]*?)<\/code><\/pre>/g;

    return html.replace(codeBlockRegex, (match, codeContent) => {
        if (codeContent.includes('╭') && (
            codeContent.includes('DÉCOUVERTE') ||
            codeContent.includes('CONFIRMÉ') ||
            codeContent.includes('EXPERT'))) {

            const boxes = codeContent.split('╭────────────────────────╮').filter((box: string) => box.trim());
            const profiles: Array<{ title: string, allocations: Array<{ category: string, percentage: number }>, focus: string[] }> = [];

            boxes.forEach((box: string) => {
                const lines = box.split('\n').map((line: string) => line.trim()).filter((line: string) => line);

                if (lines.length === 0) return;

                let title = '';
                const allocations: Array<{ category: string, percentage: number }> = [];
                const focus: string[] = [];
                let inFocusSection = false;

                lines.forEach((line: string) => {
                    const cleanLine = line.replace(/[│╰─]/g, '').trim();

                    if (!cleanLine) return;

                    if (cleanLine.match(/^(DÉCOUVERTE|CONFIRMÉ|EXPERT)/)) {
                        title = cleanLine;
                    } else if (cleanLine.match(/^▔+$/)) {
                        // Skip separator
                    } else if (cleanLine.match(/\d+%/)) {
                        const match = cleanLine.match(/^([A-Za-z-]+)\s+(\d+)%/);
                        if (match) {
                            const category = match[1];
                            const percentage = parseInt(match[2]);
                            allocations.push({ category, percentage });
                        }
                    } else if (cleanLine.match(/^▬+░*$/)) {
                        // Skip progress bar visualization
                    } else if (cleanLine.startsWith('Focus:')) {
                        inFocusSection = true;
                        const artist = cleanLine.replace('Focus:', '').trim();
                        if (artist) focus.push(artist);
                    } else if (inFocusSection && cleanLine) {
                        focus.push(cleanLine);
                    }
                });

                if (title) {
                    profiles.push({ title, allocations, focus });
                }
            });

            if (profiles.length > 0) {
                let profileHtml = '<div class="allocation-profiles">';
                profiles.forEach((profile) => {
                    profileHtml += `
            <div class="allocation-card">
              <div class="allocation-title">${profile.title}</div>
              <div class="allocation-divider"></div>
              <div class="allocation-items">
          `;

                    profile.allocations.forEach((allocation) => {
                        profileHtml += `
              <div class="allocation-item">
                <div class="allocation-label">
                  <span class="allocation-category">${allocation.category}</span>
                  <span class="allocation-percentage">${allocation.percentage}%</span>
                </div>
                <div class="allocation-progress-bar">
                  <div class="allocation-progress-fill" style="width: ${allocation.percentage}%"></div>
                </div>
              </div>
            `;
                    });

                    if (profile.focus.length > 0) {
                        profileHtml += `
              <div class="allocation-focus">
                <div class="allocation-focus-label">Focus:</div>
                <div class="allocation-focus-artists">
                  ${profile.focus.map(artist => `<span class="allocation-artist">${artist}</span>`).join('')}
                </div>
              </div>
            `;
                    }

                    profileHtml += `
              </div>
            </div>
          `;
                });
                profileHtml += '</div>';

                return profileHtml;
            }
        }

        return match;
    });
}
